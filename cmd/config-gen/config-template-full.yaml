## Generated by config-gen DO NOT EDIT
input:
  label: "ingest_server_input"
  dimo_http_server:
      address: 0.0.0.0:9443
      path: /
      allowed_verbs:
        - POST
      timeout: 5s
      rate_limit: "connection_rate_limit"
      tls:
        enabled: true
        client_root_cas_file: /etc/ssl/certs/dis/root_ca.crt
        server_certs:
          - cert_file: /etc/ssl/certs/dis/tls.crt
            key_file: /etc/ssl/certs/dis/tls.key
        require_mutual_tls: true
      sync_response:
        last_message_only: true
        status: ${!meta("response_status").or(200)}
        headers:
          Content-Type: application/octet-stream

pipeline:
  processors:
    - label: "file_index_migration"
      dimo_file_index_migration:
        dsn: clickhouse://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/${CLICKHOUSE_INDEX_DATABASE}?username=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}&secure=true&dial_timeout=5s
    - label: signal_db_migration
      dimo_signal_migration:
        dsn: clickhouse://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/${CLICKHOUSE_SIGNAL_DATABASE}?username=${CLICKHOUSE_USER}&password=${CLICKHOUSE_PASSWORD}&secure=true&dial_timeout=5s
    # If label name change, update the alerts
    - label: "convert_cloudevent"
      switch:
        {{- range .Connections }}
        - check: 'metadata("dimo_cloudevent_source") == "{{ .ConnectionID }}"'
          processors:
            - label: convert_cloudevent_{{ toLower .ConnectionName }}
              dimo_cloudevent_convert:
                module_name: {{ .ModuleName }}
                module_config: {{ base64 .ModuleConfig }}
        {{- end }}
        - check: ''
          processors:
            - set_error:
                message: 'unknown connection ${! meta("dimo_cloudevent_source") }'
    # If label name change, update the alerts
    - label: "convert_cloudevent_errors"
      catch:
        - log:
            level: WARN
            message: "failed to convert to cloudevent: ${!error()}"
            fields_mapping: |
                source = metadata("dimo_cloudevent_source")
                producer = this.producer.or("unknown")
                subject = this.subject.or("unknown")
                type = this.type.or("unknown")
                id = this.id.or("unknown")
        # mutate message for http response and metrics
        - mutation: |
              meta dimo_component = "dimo_cloudevent_convert"
              meta response_message = "failed to convert to cloudevent: " + error()
        # Update error count metric
        - resource: "dimo_error_count"
        # Send bad request response
        - resource: "dimo_bad_request_sync_response"
        # Drop the message
        - mapping: root = deleted()
    # If label name change, update the alerts
    - label: "convert_signals"
      switch:
        - check: 'metadata("dimo_message_content").or("") == "dimo_partial_cloudevent"'
          processors:
            - resource: "dimo_partial_index_count"
        {{- range .Connections }}
        - check: 'metadata("dimo_message_content").or("") == "dimo_valid_cloudevent" && metadata("dimo_cloudevent_type").or("") == "dimo.status" && metadata("dimo_cloudevent_source") == "{{ .ConnectionID }}"'
          processors:
            - label: convert_signals_{{ toLower .ConnectionName }}
              dimo_signal_convert:
                module_name: {{ .ModuleName }}
                module_config: {{ base64 .ModuleConfig }}
        {{- end }}
    # If label name change, update the alerts
    - label: "convert_signal_errors"
      catch:
      -  mutation: |
            meta dimo_component = "dimo_signal_convert"
            meta response_message = "failed to convert to cloudevent to signals: " + error()
      - log:
          level: WARN
          message: "failed to convert cloudevent to signals"
          fields_mapping: |
            cloudevent_source = metadata("dimo_cloudevent_source").or("unknown")
            cloudevent_producer = metadata("dimo_cloudevent_producer").or("unknown")
            cloudevent_subject = metadata("dimo_cloudevent_subject").or("unknown")
            cloudevent_type = metadata("dimo_cloudevent_type").or("unknown")
            cloudevent_id = metadata("dimo_cloudevent_id").or("unknown")
            component = metadata("dimo_component").or("unknown")
            error = metadata("error").or("unknown")
      # Update error count metric
      - resource: "dimo_error_count"
      # Send bad request response
      - resource: "dimo_bad_request_sync_response"
      # Drop the message
      - mapping: root = deleted()

output:
  label: "all_outputs"
  switch:
    retry_until_success: true
    strict_mode: true
    cases:
      # Output for valid signals
      - check: 'metadata("dimo_message_content").or("") == "dimo_valid_signal"'
        output:
          label: "insert_signal"
          kafka:
            addresses:
              - '${KAFKA_BOOTSTRAP_SERVERS:localhost}:${KAFKA_BOOTSTRAP_PORT:9092}'
            topic: '${KAFKA_SIGNALS_TOPIC:topic.dis.signal}'
            client_id: ${CONTAINER_NAME:localhost}-dis-output
            target_version: 2.8.1
            # key: '${! meta("kafka_key") }' 
            partitioner: murmur2_hash
            compression: '${KAFKA_COMPRESSION:none}'
            max_in_flight: 100000
            ack_replicas: false
            max_msg_bytes: 52428800
            timeout: 5s
            batching:
              count: 0
              byte_size: 0
              period: 10ms
            max_retries: 5
            backoff:
              initial_interval: 200ms
              max_interval: 1s
              max_elapsed_time: 30s
      # Output for valid cloudevents
      - check: 'metadata("dimo_message_content").or("") == "dimo_valid_cloudevent" && metadata("dimo_cloudevent_index").or("") != ""'
        output:
          label: "insert_valid_cloudevent"
          kafka:
            addresses:
              - '${KAFKA_BOOTSTRAP_SERVERS:localhost}:${KAFKA_BOOTSTRAP_PORT:9092}'
            topic: '${KAFKA_VALID_CE_TOPIC:topic.valid.cloudevent}'
            client_id: ${CONTAINER_NAME:localhost}-dis-output
            target_version: 2.8.1
            # key: '${! meta("kafka_key") }' 
            partitioner: murmur2_hash
            compression: '${KAFKA_COMPRESSION:none}'
            max_in_flight: 100000
            ack_replicas: false
            max_msg_bytes: 52428800
            timeout: 5s
            batching:
              count: 0
              byte_size: 0
              period: 10ms
            max_retries: 5
            backoff:
              initial_interval: 200ms
              max_interval: 1s
              max_elapsed_time: 30s

      # Output for partial cloudevents
      - check: 'metadata("dimo_message_content").or("") == "dimo_partial_cloudevent" && metadata("dimo_cloudevent_index").or("") != ""'
        output:
          label: "insert_partial_cloudevent"
          kafka:
            addresses:
              - '${KAFKA_BOOTSTRAP_SERVERS:localhost}:${KAFKA_BOOTSTRAP_PORT:9092}'
            topic: '${KAFKA_PARTIAL_CE_TOPIC:topic.partial.cloudevent}'
            client_id: ${CONTAINER_NAME:localhost}-dis-output
            target_version: 2.8.1
            # key: '${! meta("kafka_key") }' 
            partitioner: murmur2_hash
            compression: '${KAFKA_COMPRESSION:none}'
            max_in_flight: 100000
            ack_replicas: false
            max_msg_bytes: 52428800
            timeout: 5s
            batching:
              count: 0
              byte_size: 0
              period: 10ms
            max_retries: 5
            backoff:
              initial_interval: 200ms
              max_interval: 1s
              max_elapsed_time: 30s
      - check: ''
        output:
          label: "drop_message"
          drop: {}
